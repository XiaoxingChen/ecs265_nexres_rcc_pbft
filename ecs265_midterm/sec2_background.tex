% CAPER: CAPER: A cross-application permissioned blockchain [5]
% Hyperledger Fabric: Hyperledger Fabric: A distributed operating system % for permissioned blockchains [6]
% BlockchainDB: BlockchainDB: A shared database on blockchains [7]
% Blockplane: Blockplane: A global-scale byzantizing middleware [9]
% PBFT: Practical byzantine fault tolerance and proactive recovery [15]
% ZYZZYVA: Zyzzyva: Speculative byzantine fault tolerance [16]
% SBFT: SBFT: A scalable and decentralized trust infrastructure [17]
% HOTSTUFF: HotStuff: BFT consensus with linearity and responsiveness [18]
% POE: Proof-ofexecution: Reaching consensus through fault-tolerant speculation [19]
% SPINNING: Spin oneâ€™s wheels? byzantine fault tolerance with a spinning primary [22]
% PRIME: Prime: Byzantine replication under attack [23]
% RESILIENTDB: ResilientDB: Global scale resilient blockchain fabric [43]
\section{Background and Challenges}
Compared with traditional distributed database systems, consensus-based database systems provide more resilience during failures and stronger support for data provenance, and it has become key to build resilient and strong consistent distributed systems. In addition, fueled by the emergence of blockchain technology, there is a surge in consensus-based data systems, such as \textit{CAPER}, \textit{Hyperledger Fabric}, \textit{BlockchainDB} and \textit{Blockplane}. In a consensus-based system, consensus protocol is the core. The formal requirements for a consensus protocol include: agreement (all correct process must agree on the same value), weak validity (for each correct process, its output must be the input of some correct process), strong validity (if all correct processes receive the same input value, then they must all output that value) and termination (all processes must eventually decide on an output value). Based on these attributes, consensus protocol enables independent participants to manage a single common database by reliably and continuously replicating a unique sequence of transactions among all participants. Nowadays, most practical systems use consensus protocols that follow the classical primary-backup design of PBFT, in which a single primary replica proposes transactions by broadcasting them to all other replicas first. Well-known examples of such protocols are \textit{ZYZZYVA}, \textit{SBFT}, \textit{HOTSTUFF} and \textit{POE}. \\
However, there is an issue of suffering from the limitation of single-replica throughput in traditional primary-backup consensus protocols: consensus protocol shows that the design of it underutilized available network resources, which prevents the maximization of transaction throughput (the throughput of these protocols is determined mainly by the outgoing bandwidth of the primary). Although the obvious solution to solve this issue is using several primaries, recent protocols (e.g. \textit{HOTSTUFF}, \textit{SPINNING} and \textit{PRIME}) regularly switch primaries all require a switch from a primary happens after all proposals of that primary are processed. And this method can not address the underutilization of resources observed. \\
Hence, previous work has proposed the idea of concurrent consensus that shows much higher throughput achievement by effectively utilizing all available system resources. To push this idea into practice, the RCC paradigm was proposed that turns any primary-backup consensus protocol into a concurrent consensus protocol by running many consensus instances concurrently. RCC makes every replica a primary of a consensus-instance that replicates transactions among all replicas, as well as provides the necessary coordination between there consensus-instances to coordinate execution and deal with faulty primaries. The design goals of RCC are:
\begin{enumerate}
    \item RCC provides consensus among replicas on the client transactions to be executed and the order in which they are completed.
    \item  Clients can interact with RCC to force the execution of their transactions and learn the outcome of execution.
    \item  RCC is a design paradigm that can be applied to any primary-backup consensus protocol, turning it into a concurrent consensus protocol.
    \item  In RCC, instances with non-faulty primaries are always able to propose transactions at maximum throughput (concerning the resources available to any replica), this is independent of faulty behavior by any other replica.
    \item  In RCC, dealing with faulty primaries does not interfere with the operations of other instances.
\end{enumerate} \\
Therefore, RCC paradigm can be used to make normal primary-backup consensus protocols \textit{concurrent}. Moreover, RCC is capable of making consensus-based systems more resilient to failures by sharply reducing the impact f faulty replicas on the throughput and operations of the system. With these advantages, RCC has been put to the test by implementing it in \textit{RESILIENTDB} showing that RCC achieves up to 2.75 times higher throughput than other consensus protocols and can be scaled to 91 replicas. However, though the performance results of RCC in \textit{RESILIENTDB} fits the theoretical expectation, the actual bottleneck was CPU computing capability but not network bandwidth. Then, it is of great significance to \textbf{implement RCC in NexRes} and get more convincing performance results.
